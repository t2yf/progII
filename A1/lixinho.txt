int gbv_view(const Library *lib, const char *docname) {
     if (lib->count == 0) {
         printf("Nada foi inserido no .gbv\n");
         return -1;
     }

     //Pegar tamanho do docs
     int idx = docs_name_cmp(lib, docname);
     if (idx == -1) {
         printf("Docs não inserido no .gbv\n");
         free(lib->docs);
         return -1;
     }
     long size_doc_to_view = lib->docs[idx].size;

     //fprintf(stderr, "Tamanho do docs: %ld\n", size_doc_to_view);

     //Abrir arquivo
     FILE *docs = fopen(docname, "rb");

     if (!docs) {
         perror("Erro: Não foi possível abrir o docs no view\n");
         return -1;
     }

     rewind(docs);

     //Identificar se docs é texto
     int text_doc = is_text_docs(docname);

     //fprintf(stderr,"É texto? %d\n", text_doc);

     //TODO TODO alterar valor, personalizado para cada documento
     long size_buffer = 10;
     char *buffer = malloc(size_buffer);

     long start_doc = 0;
     long end_doc = size_doc_to_view;
     //fprintf(stderr, "end_doc: %ld\n", end_doc);

     //Começa no início do arquivo
     long mini_size_buffer = size_buffer;
     long start = 0;
     //fprintf(stderr, "start: %ld\n", start);
     long end = size_buffer;
     //fprintf(stderr, "end: %ld\n", end);
     fseek(docs, start, SEEK_SET);
     fread(buffer, size_buffer, 1, docs);
     view_docs(buffer, text_doc, size_buffer);

     //Ler operação
     char op = read_only_one_char();

     while (op != 'q') {
         switch (op) {
             case 'n': {
                 start = end;
                 if (start == end_doc || size_doc_to_view <= size_buffer) {
                     printf("----------------\nFim do documento\n----------------\n");
                     break;
                 }
                 //fprintf(stderr, "start: %ld\n", start);
                 end = end + size_buffer;
                 //fprintf(stderr, "end: %ld\n", end);

                 if (end <= end_doc) {
                     //Imprimir
                     fseek(docs, start, SEEK_SET);
                     fread(buffer, size_buffer, 1, docs);
                     view_docs(buffer, text_doc, size_buffer);
                 } else {
                     //TODO arrumar problema

                     mini_size_buffer = end_doc - start;
                     //fprintf(stderr, "mini_size_buffer: %ld\n", mini_size_buffer);
                     end = end_doc;
                     //fprintf(stderr, "end: %ld\n", end);

                     //fprintf(stderr, "start: %ld\n", start);

                     char *mini_buffer = malloc(mini_size_buffer);

                     fseek(docs, start, SEEK_SET);
                     fread(mini_buffer, mini_size_buffer, 1, docs);
                     view_docs(mini_buffer, text_doc, mini_size_buffer);

                     free(mini_buffer);

                     break;
                 }

                 //TODO eu libero o buffer aqui?
                 break;
             }
             case 'p': {
                 end = start;
                 if (end == start_doc || size_doc_to_view <= size_buffer) {
                     printf("-------------------\nInicio do documento\n-------------------\n");
                     break;
                 }
                 fprintf(stderr, "end: %ld\n", end);
                 start = start - size_buffer;
                 fprintf(stderr, "start: %ld\n", start);


                 if (start > start_doc) {
                     //Imprimir
                     fseek(docs, start, SEEK_SET);
                     fread(buffer, size_buffer, 1, docs);
                     view_docs(buffer, text_doc, size_buffer);
                 } else {
                     start = start_doc;
                     mini_size_buffer = end - start;
                     fprintf(stderr, "mini_size_buffer: %ld\n", mini_size_buffer);
                     fprintf(stderr, "start: %ld\n", start);

                     fprintf(stderr, "end: %ld\n", end);

                     char *mini_buffer = malloc(mini_size_buffer);

                     fseek(docs, start, SEEK_SET);
                     fread(mini_buffer, mini_size_buffer, 1, docs);
                     view_docs(mini_buffer, text_doc, mini_size_buffer);

                     free(mini_buffer);

                     break;
                 }

                 break;
             }
             default: {
                 printf("Entre com uma opção válida: 'n' para o próximo bloco; 'p' para o bloco anterior; 'q' para sair\n");
                 break;
             }
         }
         op = read_only_one_char();
     }

     //Liberar memória
     free(buffer);
     free(lib->docs);
     fclose(docs);

     return 0;
 }